# -----------------------------------------------------
# なでしこプラグイン「jsplugin2text.nako3」
#-------------------------------------------------
# 入力: plugin_xxx.(mts|mjs|js)
# 出力: wiki textデータ
# -----------------------------------------------------

関数定義とは変数=「」
関数説明とは変数＝「」
助詞定義JSONとは変数＝「」
ヨミガナとは変数＝「」
カレントプラグインとは変数＝「」
可変引数とは変数＝「」
結果＝「」
SRC_URL=""
LINENO=0

### パスをプラグイン要約作成
もし、プラグイン名＝「メイン」ならば
　　コマンドラインの要素数
　　もし、それが3以下ならば
　　　　「[使い方] cnako3 jsplugin2text.nako3 (JSプラグインファイル)」を表示。
　　　　終わる。
　　ここまで。
　　コマンドライン[3]を「(拡張プラグイン)」でプラグイン要約作成
　　それを表示。
ここまで。

●プラグイン要約作成(Fをプラグイン種類で)
　　# 対象のプラグインが存在するか確認
　　OS=OS取得
　　もし、OS="darwin"ならば # macOSのときだけフルチェックする
　　　　Fが存在。
　　　　もし、そうでなければ
　　　　　　「[ERROR] jsplugin2text.nako3 で『{F}』が存在しません！」のエラー発生。
　　　　ここまで。
　　違えば
　　　　Fが存在。
　　　　もし、そうでなければ、戻る。
　　ここまで。
　　# プラグイン名を決定
　　Ｆからファイル名抽出
　　「\.(php|mjs|mts|js|ts)$」を空に正規表現置換;
　　それをプラグイン名に代入。
　　結果＝「■{プラグイン名}{プラグイン種類}{改行}」
　　Fを『/\.php$/』で正規表現マッチ。
　　もし、そうならば
　　　　FをPHPプラグイン変換。
　　　　結果を戻す。
　　ここまで。
　　もし、プラグイン名＝「plugin_browser」ならば
　　　　FをプラグインREQUIRE読み込み。
　　　　結果を戻す。
　　違えば
　　　　Ｆを開く
　　ここまで。
　　# ---
　　LINENO=1
　　改行で区切る
　　ここから反復
　　　　毎行処理。
　　　　LINENO=LINENO+1
　　ここまで。
　　結果を戻す。
ここまで。

●(Fを)PHPプラグイン変換
　　Fを開く。
　　「=>」を「:」に置換
　　改行で区切る
　　反復
　　　　毎行処理。
　　ここまで。
　　結果を戻す。
ここまで。

●(Fを)プラグインREQUIRE読み込み
　　SS=「」
　　# 結果＝「■plugin_browser(wnako)」&改行
　　DIR=Fからパス抽出。
　　Fを開いて改行で区切る
　　反復
　　　　対象を「import .*\'(.+\.mjs)\'」で正規表現マッチ。
　　　　もし、そうならば
　　　　　　対象を「plugin_[0-9a-zA-Z_]+.mjs」で正規表現マッチ。
　　　　　　もし、そうならば
　　　　　　　　FNAME=それの「.mjs」を「.mts」に置換。
　　　　　　　　SRC_URL=「https://github.com/kujirahand/nadesiko3/blob/master/src/{FNAME}」
　　　　　　　　「{DIR}/{FNAME}」を開く
　　　　　　　　LINENO=1
　　　　　　　　改行で区切る
　　　　　　　　反復
　　　　　　　　　　毎行処理。
　　　　　　　　　　LINENO=LINENO+1
　　　　　　　　ここまで。
　　　　　　ここまで。
　　　　ここまで
　　ここまで
　　# 結果を表示。
ここまで

●(Sの)定数定義処理
    # 名前と定数判定
    Ｓを『/'(.+?)'\s*:.+'(const|var)'/』で正規表現マッチ。
    定数定義＝抽出文字列[0]
    もし、 定数定義＝「」ならば
    　　「原因不明のエラー。定数名が不明です。{S}」のエラー発生。
    ここまで。
    抽出文字列[1]をトリムして、「const」を「定数」に置換して「var」を「変数」に置換して、Fタイプに代入。
    ＃定義とヨミガナを分割
    N=Sを『// @』で区切る。
    もし、要素数(N) = 1ならば
    　　ERR=「{プラグイン名}の定数`{定数定義}`にヨミガナがありません。{改行}=>{S}」
    　　ERRと表示。
    　　ERRのエラー発生。
    ここまで。
    ヨミガナ＝N[1]
    ＃定数でオブジェクト定義があったりする場合
    NN=N[0]を「value」で区切る。
    V=NN[1]
    VをトリムしてVに代入。
    V=Vの『/(\}|\])\,\s*$/』を「」に正規表現置換。
    V=Vの『/^'?\s*:/』を「」に正規表現置換。
    定数値＝V
    結果＝結果＆「| {Fタイプ} | {定数定義} | | {定数値} | {ヨミガナ} | {SRC_URL}#L{LINENO}{改行}」
ここまで。


●(Sを)見出し語判定とは
    # 見出し語？
    Ｓを『/^\/\/ @(.+)/』で正規表現マッチ
    もし、そうならば
        それの「^\/\/\s*@」を「」に正規表現置換して見出しに代入
        もし、MID(見出し,1,3)="ts-"ならば
        　　いいえで戻る。
        ここまで。
        結果＝結果＆「●{見出}{改行}」
        はいで、戻る
    ここまで。
    いいえで、戻る。
ここまで

●(Sを)定数判定とは
    # 定数かどうかだけを判定
    Ｓを『/'(.+?)'\s*:.+'(const|var)'/』で正規表現マッチ。
    もし、そうならば
        ＃定数定義である
        Sの定数定義処理。
    違えば
        いいえで戻る。
    ここまで。   
ここまで。

●（Sを）関数判定
    # 関数定義？ // (例えば) '空ハッシュ': { // @空のハッシュを返す // @からはっしゅ
    Ｓを『/^\s*'(.+?)'\s*\:\s*(\{|\[)\s*\/\/\s*\@(.+)$/』で正規表現マッチ
    もし、そうならば
        助詞定義JSON=[]
        ヨミガナ＝「」
        関数定義＝トリム(抽出文字列[0])
        関数説明＝トリム(抽出文字列[2])
        関数説明の「|」を「/」へ置換して、関数説明に代入。
        # 関数定義を表示
        可変引数＝オフ。
        関数説明で「// @」が何文字目
        もし、それ＞０ならば
        　　関数説明を「// @」で区切って、Aに代入。
        　　関数説明＝トリム(A[0])
        　　ヨミガナ＝トリム(A[1])
        ここまで。
        もし、ヨミガナが空ならば
        　　ERR=「--- [エラー] ---『{関数定義}』でヨミガナがありません{改行}{S}」
        　　ERRのエラー発生。
        ここまで。
        はいで戻る。
    ここまで
    いいえで戻る。
ここまで。

●（Sを）関数助詞定義判定とは
　　Ｓを『/'?josi'?\s*\:\s*(.+),$/』で正規表現マッチ
    もし、そうならば
        それ＝抽出文字列[0]
        トリム。
        #「[]」を「['']」に置換。
        「'」を「"」に置換。# '
        JSONデコード。
        助詞定義JSONに代入。
        はいで、戻る。
    ここまで
    いいえで、戻る。
ここまで

●（Sを)毎行処理
    S = トリム(S)
    # @ の例外
    「// eslint」がSで何文字目。もし、そうならば、戻る。
    「@ts-ignore」がSで何文字目。もし、そうならば、戻る。
　　Sを見出し語判定。
　　もし、そうならば、戻る。
  　Sを定数判定。
  　もし、そうならば、戻る。
  　Sを関数判定。
  　もし、そうならば、戻る。
    # 関数定義の続き
    もし、関数定義≠空ならば
        # typeの行なら次の行を読むようにする
        Ｓを『/'?type'?\s*\:\s*'func'/』で正規表現マッチ
        もし、そうならば、戻る。
        Ｓを『/uses\s*\:/』で正規表現マッチ
        もし、そうならば、戻る。
        Ｓを『/asyncFn\s*\:\s*(true|false)/』で正規表現マッチ
        もし、そうならば、戻る。
        Ｓを『/pure\s*\:\s*(true|false)/』で正規表現マッチ
        もし、そうならば、戻る。
        Ｓを『/'?return_none'?\s*\:\s*(true|false)/』で正規表現マッチ
        もし、そうならば、戻る。
        # 助詞の定義があるか?
        Sを関数助詞定義判定。
        もし、そうならば、戻る。
        Sを『/'?isVariableJosi'?\:\s*(true|false)/』で正規表現マッチ。
        もし、そうならば
        　　もし、抽出文字列[0]＝"true"ならば
        　　　　可変引数＝オン。
        　　　　関数説明＝関数説明＆「(可変引数)」
        　　ここまで。
        　　戻る。
        ここまで。
        # JS関数定義？ そうであれば、JSに対する引数名を得られる
        Sを『/^'?fn'?\s*\:\s*(async function|function)\s*\((.*?)\)/』で正規表現マッチ。
        もし、そうならば
            助詞定義＝「」
            # システムオブジェクトへの参照は、なでしこ関数定義と関係ないので除去
            それ＝抽出文字列[1]
            「/(\,\s*sys|sys)\:?\s*[a-zA-Z]*$/」を「」に正規表現置換
            トリム。
            # JS引数の一覧を取得
            引数一覧=[]
            「,」で区切る
            反復
                「\:\s*[a-z]+」を「」に正規表現置換。
                大文字変換してトリムして、引数名に代入。
                もし、引数名＝空ならば、続ける。
                引数一覧に引数名を配列追加。
            ここまで。
            もし、要素数(引数一覧)≠要素数(助詞定義JSON)ならば
              「*** [警告] {カレントプラグイン}:『{関数定義}』で助詞の定義がJS関数の定義と異なります」と表示。
              引数一覧を表示。
              終わる。
            ここまで。
            AA=[]
            #「@@」&(引数一覧をJSONエンコード)を表示。
            Iを0から9まで繰り返す
                SS=「」
                NOを0から9まで繰り返す
                    もし、NO>=要素数(引数一覧)ならば、続ける。
                    もし、NO>=要素数(助詞定義JSON)ならば、続ける。
                    もし、I>=要素数(助詞定義JSON[NO])ならば、続ける。
                    ARG＝引数一覧[NO]
                    JOSI＝助詞定義JSON[NO][I]
                    SS = SS & ARG & JOSI
                ここまで;
                もし、SS≠空ならば
                  AAにSSを配列追加。
                ここまで。
            ここまで
            助詞定義=AAを「/」で配列結合
            もし、助詞定義="undefined"ならば
              「*** [警告] {カレントプラグイン}:『{関数定義}』で助詞定義がundefinedです」と表示。
              助詞定義JSONをJSONエンコードして表示。
              AAを表示
              終わる。
            ここまで
            助詞定義＝助詞定義の「$」を「」に置換。
            結果＝結果＆「| 関数 | {関数定義} | {助詞定義} | {関数説明} | {ヨミガナ} | {SRC_URL}#L{LINENO}」&改行
            関数定義＝「」
            戻る。
        ここまで。
        # いずれにも合致しない場合
        「[エラー]({カレントプラグイン}):『{関数定義}』で定義不明のエラー{改行}{S}」を表示。
        終わる。
    ここまで
    関数定義＝「」
    定数定義＝「」
ここまで。
